Define the Dirichlet convolution $f*g(n)$ as:

$$f*g(n)=\sum^n_{d=1}[d|n]f(n)g(\frac{n}{d})$$

Assume we are going to calculate some function $S(n)=\sum^n_{i=1}f(i)$,
where $f(n)$ is a multiplicative function.
Say we find some $g(n)$ that is simple to calculate,
and $\sum^n_{i=1}f*g(i)$ can be figured out in $O(1)$ complexity.
Then we have

\begin{equation*}
\begin{split}
\sum^n_{i=1}f*g(i)	&=\sum^n_{i=1}\sum_d[d|i]g(\frac{i}{d})f(d)\\
					&=\sum^n_{\frac{i}{d}=1}\sum^{\floor*{\frac{n}{\frac{i}{d}}}}_{d=1}g(\frac{i}{d})f(d)\\
					&=\sum^n_{i=1}\sum^{\floor*{\frac{n}{i}}}_{d=1}g(i)f(d)\\
					&=g(1)S(n)+\sum^n_{i=2}g(i)S(\floor*{\frac{n}{i}})\\
S(n)				&=\frac{\sum^n_{i=1}f*g(i)-\sum^n_{i=2}g(i)S(\floor*{\frac{n}{i}})}{g(1)}\\
\end{split}
\end{equation*}


It can be proven that $\floor*{\frac{n}{i}}$ has at most $O(\sqrt{n})$ possible values.
Therefore, the calculation of $S(n)$ can be reduced to $O(\sqrt{n})$ calculations of $S(\floor*{\frac{n}{i}})$.
By applying the master theorem, it can be shown that the complexity of such method is $O(n^{\frac{3}{4}})$.

Moreover, since $f(n)$ is multiplicative, we can process the first $n^{\frac{2}{3}}$ elements via linear sieve,
and for the rest of the elements, we apply the method shown above. The complexity can thus be enhaced to $O(n^{\frac{2}{3}})$.

For the prefix sum of Euler's function $S(n)=\sum^n_{i=1}\varphi(i)$, notice that $\sum_{d|n}\varphi(d)=n$.
Hence $\varphi*I(n)=id(n)$.($I(n)=1,id(n)=n$)
Now let $g(n)=I(n)$, and we have $S(n)=\sum^n_{i=1}i-\sum^n_{i=2}S(\floor*{\frac{n}{i}})$.

For the prefix sum of Mobius function $S(n)=\sum^n_{i=1}\mu(i)$, notice that $\mu*I(n)=[n=1]$.
Hence $S(n)=1-\sum^n_{i=2}S(\floor*{\frac{n}{i}})$.

Example code :

\begin{lstlisting}
/*	Prefix sum of multiplicative functions :
		CUBEN : N ^ (1 / 3).
		p_f : the prefix sum of f (x) (1 <= x <= th).
		p_g : the prefix sum of g (x) (0 <= x <= N).
		p_c : the prefix sum of f (x) * g (x) (0 <= x <= N).
		th : the thereshold, generally should be x ^ (2 / 3).
		REMEMBER THAT x IN p_g (x) AND p_c (x) MAY BE LARGER THAN MOD!!
*/

template <int CUBEN = 11000>
struct prefix_mul {

	typedef long long (*func) (long long);

	func p_f, p_g, p_c;
	long long n, mod, th, inv;
	std::pair <bool, long long> mem[CUBEN];

	prefix_mul (func p_f, func p_g, func p_c) : p_f (p_f), p_g (p_g), p_c (p_c) {}

	void euclid (long long a, long long b, long long &x, long long &y) {
		if (b == 0) x = 1, y = 0;
		else euclid (b, a % b, y, x), y -= a / b * x;
	}

	long long inverse (long long x, long long m) {
		long long a, b;
		euclid (x, m, a, b);
		return (a % m + m) % m;
	}

	long long calc (long long x) {
		if (x <= th) return p_f (x);
		if (mem[n / x].first) return mem[n / x].second;
		mem[n / x].first = true;
		long long ans = 0;
		for (long long i = 2, la; i <= x; i = la + 1) {
			la = x / (x / i);
			ans = (ans + (p_g (la) - p_g (i - 1) + mod) * calc (x / i)) % mod;
		}
		ans = p_c (x) - ans; if (ans < 0) ans += mod; ans = ans * inv % mod;
		return mem[n / x].second = ans;
	}

	long long solve (long long n, long long th, long long mod) {
		if (n <= 0) return 0;
		prefix_mul::n = n; prefix_mul::mod = mod; prefix_mul::th = th;
		inv = inverse (p_g (1), mod);
		std::fill (mem, mem + CUBEN, std::make_pair (false, 0ll));
		return calc (n); 
	}

};
\end{lstlisting}

