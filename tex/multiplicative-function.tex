\subsubsection{Dirichlet inversion}
Define the Dirichlet convolution $f*g(n)$ as:

$$f*g(n)=\sum^n_{d=1}[d|n]f(n)g(\frac{n}{d})$$

Assume we are going to calculate some function $S(n)=\sum^n_{i=1}f(i)$,
where $f(n)$ is a multiplicative function.
Say we find some $g(n)$ that is simple to calculate,
and $\sum^n_{i=1}f*g(i)$ can be figured out in $O(1)$ complexity.
Then we have

\begin{equation*}
\begin{split}
\sum^n_{i=1}f*g(i)	&=\sum^n_{i=1}\sum_d[d|i]g(\frac{i}{d})f(d)\\
					&=\sum^n_{\frac{i}{d}=1}\sum^{\floor*{\frac{n}{\frac{i}{d}}}}_{d=1}g(\frac{i}{d})f(d)\\
					&=\sum^n_{i=1}\sum^{\floor*{\frac{n}{i}}}_{d=1}g(i)f(d)\\
					&=g(1)S(n)+\sum^n_{i=2}g(i)S(\floor*{\frac{n}{i}})\\
S(n)				&=\frac{\sum^n_{i=1}f*g(i)-\sum^n_{i=2}g(i)S(\floor*{\frac{n}{i}})}{g(1)}\\
\end{split}
\end{equation*}


It can be proven that $\floor*{\frac{n}{i}}$ has at most $O(\sqrt{n})$ possible values.
Therefore, the calculation of $S(n)$ can be reduced to $O(\sqrt{n})$ calculations of $S(\floor*{\frac{n}{i}})$.
By applying the master theorem, it can be shown that the complexity of such method is $O(n^{\frac{3}{4}})$.

Moreover, since $f(n)$ is multiplicative, we can process the first $n^{\frac{2}{3}}$ elements via linear sieve,
and for the rest of the elements, we apply the method shown above. The complexity can thus be enhaced to $O(n^{\frac{2}{3}})$.

For the prefix sum of Euler's function $S(n)=\sum^n_{i=1}\varphi(i)$, notice that $\sum_{d|n}\varphi(d)=n$.
Hence $\varphi*I=id$. ($I(n)=1,id(n)=n$)
Now let $g(n)=I(n)$, and we have $S(n)=\sum^n_{i=1}i-\sum^n_{i=2}S(\floor*{\frac{n}{i}})$.

For the prefix sum of Mobius function $S(n)=\sum^n_{i=1}\mu(i)$, notice that $\mu*I=(n)\{[n=1]\}$.
Hence $S(n)=1-\sum^n_{i=2}S(\floor*{\frac{n}{i}})$.

Some other convolutions include $(p^k)\{1-p\}*id=I$, $(p^k)\{p^k-p^{k+1}\}*id^2=id$ and $(p^k)\{p^{2k}-p^{2k-2}\}*I=id^2$.

Example code :

\begin{lstlisting}
/*	Prefix sum of multiplicative functions :
		p_f : the prefix sum of f (x) (1 <= x <= th).
		p_g : the prefix sum of g (x) (0 <= x <= N).
		p_c : the prefix sum of f (x) * g (x) (0 <= x <= N).
		th : the thereshold, generally should be x ^ (2 / 3).
		REMEMBER THAT x IN p_g (x) AND p_c (x) MAY BE LARGER THAN MOD!!
*/

struct prefix_mul {

	typedef long long (*func) (long long);

	func p_f, p_g, p_c;
	long long n, mod, th, inv;
	std::unordered_map <long long, long long> mem;

	prefix_mul (func p_f, func p_g, func p_c, long long mod) : p_f (p_f), p_g (p_g), p_c (p_c), mod (mod) {}

	void euclid (long long a, long long b, long long &x, long long &y) {
		if (b == 0) x = 1, y = 0;
		else euclid (b, a % b, y, x), y -= a / b * x;
	}

	long long inverse (long long x, long long m) {
		long long a, b;
		euclid (x, m, a, b);
		return (a % m + m) % m;
	}

	long long calc (long long x) {
		if (x <= th) return p_f (x);
		auto d = mem.find (x);
		if (d != mem.end ()) return d -> second;
		long long ans = 0;
		for (long long i = 2, la; i <= x; i = la + 1) {
			la = x / (x / i);
			ans = (ans + (p_g (la) - p_g (i - 1) + mod) * calc (x / i)) % mod;
		}
		ans = p_c (x) - ans; if (ans < 0) ans += mod; ans = ans * inv % mod;
		return mem[x] = ans;
	}

	long long solve (long long n, long long th) {
		if (n <= 0) return 0;
		prefix_mul::n = n; prefix_mul::th = th;
		inv = inverse (p_g (1), mod);
		return calc (n); 
	}

};
\end{lstlisting}

\subsubsection{Inclusion-exclusion principle}

Let $S(u)=\sum_{i=1}^uf(i)$ be the function we want to solve. Define
$$P = \{x|x \leq n \text{ and only contains prime factors not exceeding } \sqrt{n}\}$$
We can observe that $$S(n)=\sum_{x \in P} f(x)(1 + \sum_{p=\ceil{\sqrt{n}}}^{\floor{\frac{n}{x}}}[p \text{ is prime}]f(p))$$
Due to the fact that $\floor{\frac{n}{x}}$ has $O(\sqrt{n})$ possible values, We only need to solve for
$$g(n)=\sum_{x=1}^{n}[x \in P]f(x)$$
$$h(n)=\sum_{x=1}^{n}[x \text{ is prime}]f(x)$$
And the merging will be $O(\sqrt{n})$.

For $g(n)$, let $g(n, i)=\sum_{x=1}^{n}[x \in P_i]f(x)$, where $P_i$ represents the set of numbers containing only the largest $i$ prime numbers (not exceeding $\sqrt{n}$) as their factors.
Then we have
$$g(n, i) = g(n, i - 1) + \sum_{c \geq 1}f(p_i^c)g(\frac{n}{p_i^c}, i - 1)$$
Notice that for $p_i^2 > n$ we have $g(n, i) = g(n, i - 1) + f(p_i)$.
Therefore, We can loop through $n = \floor{\frac{u}{d}}$. For each $n$, we solve for $g(n, i)$, breaking out when we meet some $i'$ such that $p_{i'}^2 > n$.
For those $i > i'$ we can infer that $g(n, i) = g(n, i' - 1) + \sum_{d = i'}^if(p_d)$.

For $h(n)$, it is critical to notice that because all $x$ we use is prime, we can find some coefficient $a$, such that 
$$h(n) = \sum_{x=1}^{n}[x \text{ is prime}]\sum_{i=1}^ka_ix^i$$
Define $h_k(n)=\sum_{x=1}^{n}[x \text{ is prime}]x^i$. Then $h(n)=\sum_{i=1}^{k}a_ih_k(n)$.
Now similar to the last paragraph, we let
$$h_k(n, i) = \sum_{x=1}^{n}[x \text{ is co-prime with the smallest } i \text { prime numbers}]x^k$$
Then
$$h_k(n, i) = h_k(n, i - 1) - p_i^kh_k(\frac{n}{p_i}, i - 1)$$
Also, for $p_i^2 > n$ we have $h_k(n, i) = h_k(n, i - 1) + p_i^k$.
Therefore, We can loop through $n = \floor{\frac{u}{d}}$. For each $n$, we solve for $h_k(n, i)$, breaking out when we meet some $i'$ such that $p_{i'}^2 > n$.
For those $i > i'$ we can infer that $h_k(n, i) = h_k(n, i' - 1) + \sum_{d = i'}^ip_d^k$.

The overall complexity is $O(\frac{n^{\frac{3}{4}}}{\log n})$.

